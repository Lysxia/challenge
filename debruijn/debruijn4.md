# Strongly-typed System F, at last

*Reference file:* [PolyTyped](src/PolyTyped.hs) and [SubstProperties](src/SubstProperties.hs).

This is where singletons library really comes in. If you go back to the [Subst](src/Subst.hs) and [Poly](src/Poly.hs), you'll see that some definitions are surrounded by Template Haskell brackets, and calls to the `singletons` library. These definitions are processed by singletons to include additional copies.

For example, the singletons library defines the `STy` datatype that is the 
"singleton" analogue of the `Ty` datatype from [Poly](src/Poly.hs). 

This means that in addition to the `Ty` datatype defined in that file:

```haskell
data Ty = IntTy | Ty :-> Ty | VarTy Idx | PolyTy Ty
```

the library also *generates* the following data type declaration (we don't have to write it)

```haskell
data STy :: Ty -> Type where
    SIntTy  :: STy IntTy
    (:%->)  :: STy a -> STy b -> STy (a :-> b)
    SVarTy  :: SIdx i -> STy (VarTy i)
    SPolyTy :: STy a -> STy (PolyTy a)
```

The `STy` type allows us to "fake" dependent types. For example, the `LamE` constructor can include a type annotation for the bound variable.

```haskell
LamE :: STy t1 -> Exp g t2 -> Exp g (t1 :-> t2)
```

More impressively, the singletons library also generates type-level analogues for the `SubstC` type class and its members using type families. There are two main differences:

  1. Type families must start with a capital letter, so in types, it is `Subst` instead of `subst`.
  2. Type families cannot be partially applied, so if we would like to talk about `subst s` instead of `subst s ty`, we need to rely on the defunctionalization symbols generated by singletons, and use `SubstSym1 s` instead.
  